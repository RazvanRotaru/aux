#pragma kernel CollisionDetection
// #pragma kernel SphereVsSphere

#include "HalfEdge.hlsl"
#include "Face.hlsl"
#include "Shape.hlsl"
#include "TransformMat.hlsl"

#define OFFSET 0
#define NUM 1
#define NA 9999999
#define EPS 1e-5


int objectsNo;

RWStructuredBuffer<uint2> halfedgeInfo;
RWStructuredBuffer<uint2> faceInfo;

RWStructuredBuffer<HalfEdge> halfedges;
RWStructuredBuffer<Face> faces;
RWStructuredBuffer<Shape> shapes;
RWStructuredBuffer<float3> points;
RWStructuredBuffer<TransformMat> mat;

RWStructuredBuffer<float2> collisions;

float3 SupportPoint(const Shape shape, const float3 dir, const float4x4 r, const float4x4 t)
{
    const uint points_offset = shape.pointInfo[OFFSET];
    const uint points_num = shape.pointInfo[NUM];

    float best_projection = -NA;
    float3 best_vert;

    for (uint i = points_offset; i < points_offset + points_num; i++)
    {
        const float3 vert = mul(r, float4(points[i], 1)).xyz;
        const float projection = dot(vert, dir);

        if (projection > best_projection)
        {
            best_projection = projection;
            best_vert = vert;
        }
    }

    return mul(t, float4(best_vert, 1)).xyz;
}

float QueryFace(const uint a_id, const uint b_id, out int face_id)
{
    const uint faces_off = faceInfo[a_id][OFFSET];
    const uint faces_num = faceInfo[a_id][NUM];

    const Shape shape = shapes[b_id];
    const float4x4 R = mat[b_id].R;
    const float4x4 T = mat[b_id].T;

    float best_distance = -NA;

    for (uint i = faces_off; i < faces_off + faces_num; i++)
    {
        const Face curr_face = faces[i];
        const float3 support_point = SupportPoint(shape, -curr_face.normal, R, T);

        const float distance = dot(curr_face.normal, support_point - curr_face.center);

        if (distance > best_distance)
        {
            best_distance = distance;
            face_id = i;
        }
    }

    return best_distance;
}

bool IsMinkowskiFace(const float3 a, const float3 b, const float3 c, const float3 d, const float3 bxa,
                     const float3 dxc)
{
    const float cba = dot(c, bxa);
    const float dba = dot(d, bxa);
    const float adc = dot(a, dxc);
    const float bdc = dot(b, dxc);

    return (cba * dba < 0.0f) && (adc * bdc < 0.0f) && (cba * bdc > 0.0f);
}

bool BuildMinkowskiFace(const HalfEdge he_a, const HalfEdge he_b)
{
    return IsMinkowskiFace(he_a.n1, he_a.n2, -he_b.n1, -he_b.n2, he_a.edge, he_b.edge);
}

float Distance(const HalfEdge he_a, const HalfEdge he_b)
{
    float3 n = cross(he_a.edge, he_b.edge);
    if (abs(length(n)) < EPS) return -NA;

    n = normalize(n);
    if (dot(n, he_a.local_vertex) < 0.0f) n *= -1.0f;

    return dot(n, he_b.vertex - he_a.vertex);
}

float QueryEdge(uint a_id, uint b_id, out uint edgeA, out uint edgeB)
{
    const uint a_he_start = halfedgeInfo[a_id][OFFSET];
    const uint a_he_end = a_he_start + halfedgeInfo[a_id][NUM];
    const uint b_he_start = halfedgeInfo[b_id][OFFSET];
    const uint b_he_end = b_he_start + halfedgeInfo[b_id][NUM];

    int count = 100;
    for (uint i = a_he_start; i < a_he_end; i += 1)
    {
        const HalfEdge he_a = halfedges[i];

        for (uint j = b_he_start; j < b_he_end; j += 1)
        {
            const HalfEdge he_b = halfedges[j];
            count += 1;

            if (!BuildMinkowskiFace(he_a, he_b)) continue;

            const float separation = Distance(he_a, he_b);
            if (separation > 0)
            {
                edgeA = i;
                edgeB = j;
                return separation;
            }
        }
    }

    edgeA = -1;
    edgeB = -1;
    return -count;
}

bool PolygonVsPolygon(const int id, const int other_id)
{
    uint face_a = 0;
    const float dist_ab = QueryFace(id, other_id, face_a);
    if (dist_ab > 0.0f)
    {
        return false;
    }

    uint face_b = 0;
    const float dist_ba = QueryFace(other_id, id, face_b);
    if (dist_ba > 0.0f)
    {
        return false;
    }


    uint edge_a = 0, edge_b = 0;
    const float dist_edge = QueryEdge(id, other_id, edge_a, edge_b);
    if (dist_edge > 0.0f)
    {
        return false;
    }

    return true;
}


[numthreads(32, 32, 1)]
void CollisionDetection(uint3 gid: SV_DispatchThreadID)
{
    if (gid.x >= objectsNo || gid.y >= objectsNo)
    {
        return;
    }
    const int id = gid.x;
    const int other_id = gid.y;

    const int index = id * objectsNo + other_id;
    collisions[index] = float2(-99, -99);

    if (other_id == id || length(collisions[index]) <= 0) return;

    if (!PolygonVsPolygon(id, other_id)) return;

    collisions[index] = float2(id, other_id);
}
